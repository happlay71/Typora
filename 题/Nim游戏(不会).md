你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim游戏/6737105)：

- 桌子上有一堆石头。
- 你们轮流进行自己的回合， **你作为先手** 。
- 每一回合，轮到的人拿掉 1 - 3 块石头。
- 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。

 

**示例 1：**

```
输入：n = 4
输出：false 
解释：以下是可能的结果:
1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
在所有结果中，你的朋友是赢家。
```

**示例 2：**

```
输入：n = 1
输出：true
```

**示例 3：**

```
输入：n = 2
输出：true
```

 

**提示：**

- `1 <= n <= 231 - 1`

# 解

由于一个人每次只能取1-3个石头，那么第二个人总能通过取第一个人取法跟4的补数(比如对方取1他就取3)，而达到稳定取到4以及后面4的倍数的目的。也就是说，如果有4的倍数的石子，那么后手永远能取到。

那么如果有不是4的倍数个石子呢？石子的个数模4必然余1-3。而先手的人，可以通过取这个余数而达到让自己成为上述的稳定取到4的倍数的石子的“后手”，也就是稳定的获胜。

*题外话*: 这和小时候玩过的经典的报数抢21游戏一样。每个人可以报连续的一到三个数，从1报到21，谁报到21谁就能赢。这时候你就会想，你先手想赢，你必须不能报18(你报18他就能报到21了)。你想不报18你必须也不能报14(你报14他就能报到17，你只能报18了)。依次类推，你不想报的数其实是2。那么很显然，你先手第一次只报个1，你就能赢。

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
```

